Адаптивная верстка сайта с нуля для начинающих 
HTML, CSS, Figma практика 
Пошаговое подробное объяснение 
Разработка сайта с 0 до результата

По сути в figma мы ищем повторяющиеся стили и выносим их в глобальные переменные

При вёрстки всё распологаем строко по дереву, сверху вниз
Начинаем с наследуемых стилей
Ни в коем случае не повторяем наследумые стили
padding-inline - изменение по оси x
padding-block - изменение по оси y
На alt можно смотреть расстояние в FIGMA

Hotkeys:
    Ctrl + K + Ctrl + 0 — свернуть все уровни (пространство имён, класс, метод и блок); 13
    Ctrl + K + Ctrl + 1 — пространство имён / @Component (для Angular); 1
    Ctrl + K + Ctrl + 2 — класс / методы; 1
    Ctrl + K + Ctrl + 3 — методы / блоки; 1
    Ctrl + K + Ctrl + 4 — блоки / внутренние блоки; 1
    Ctrl + K + Ctrl + [ или Ctrl + k + ] — текущий блок курсора; 1
    Ctrl + K + Ctrl + j — развернуть. 1

Для всех картинок нужно указывать атрибуты width и height, чтобы браузер заранее выделял под них место
и не было неприятных скачков изображения
    В КОНЦЕ ПРОЕКТА СДЕЛАТЬ!

На будущее если происходит какой-то странный баг на странице, 
хотя ты уверен что всё заебись, попробуй закрыть её полностью и открыть заново

ШАГИ РАЗРАБОТКИ ВЁРСТКИ ПО МАКЕТУ Figma:
Header:
Шаги Figma | Проект:
1. Просматриваем у всех текстов шрифты и их жирность, выделяем сколько понадобится
    - Берём нужные шрифты в googlefonts
    - Скачиваем нужные шрифты
    - Заходим на transfonter.org и меняет расширение шрифтов на WOFF2
    - Кладём шрифты в папку проекта
2. Создаём index.html, styles.css, images, icons, fonts
3. Кладём шрифты в папку
8. Выделяем блоки в поисках используемых цветов для текста
10. Просматриваем border-radius у кнопок
12. Просматриваем border у кнопок
15. Просматриваем высоту кнопок и полей ввода
17. Просматриваем ширину контентного контейнера

Шаги HTML:
4. Emit для html (!), меняем title, подключаем стили
23. Написание header | шапки (лого - a->img | контекстное меню nav->ul->li->a | div->2 button)
24. Для кнопок заранее делаем класс button для общего стиля кнопки, а header-book-button будет отвечать за условные отступы
25. Непонятные детали можно выделить вместе и экспортировать как единую картинку в формате svg
    - И соответственно вставить как svg куда нужно (например для иконки)
39. Добавили title для burger-button
40. Добавляем элемент span для burger-button для screen-reader

Шаги CSS:
5. Шрифты подключаем через @font-face {font-family: ...; src:url(./fonts/...) format('woff2'); font-weight: 300; font-style: normal; font-display: swap;}
    - Повторяем для других шрифтов
6. Нормализация стилей (копируем, вставляем)
7. Подготавливаем глобальные css переменные :root {}    (Корневой элемент - html)
9. В :root вносим глобальные цвета которые нашли :root {--color-dark: ...; --color-light: ...; --color-dark-grey: ...; --color-light-grey: ...;}
11. В :root вносим глобальный border-radius :root{--border-radius: ...;}
13. В :root вносим глобальные border :root{--border: ...;}
14. В :root Вносим глобальные семейства шрифтов :root{--font-family-base: ..., sans-serif; --font-family-accent: ..., sans-serif;}  sans-serif - запасной шрифт
16. В :root Вносим глобальные высоту :root {--input-hight: ...;}
18. В :root Вносим глобальную ширину контентного контейнера :root{--container-width: ...; --container-padding-x: ...;}
19. В :root Вносим глобальную длительность переходов :root{--transition-duration: 0.2s;}
20. Глобальные стили для body { font-family: var(--font-family-base); background-color: var(--color-dark); Далее цвет и размер обычного текста и его line-height}
21. Стили для контейнера {max-width: calc(var(--container-width) + var(--container-padding-x) * 2); margin-inline: auto; padding-inline: var(--container-padding-x)}
22. Стили для заголовков, h1 - h6 {font-weight: 700; text-transform: uppercase}
26. Точечно задаём стили для header, обязательно: {display: flex; justify-content: space-between; align-items: center; column-gap: 20px}
27. Точно также точечно задаём стили для других элементов header (Полезные стили: flex, column-gap, text-decoration: none(убирает подчеркивание у ссылок))
28. Ссылки нужно проверять на пространство на которое можно на них нажать, оно может быть расширено: height: ...; display: inline-flex; align-items: center;
29. Отдельно для всех элементов с наведением | анимациями, глобально по тегам добавляеv transition-duration: var(--transition-duration);
30. CurrentColor - значение свойства color, наследуется (Делаем это для псевдоэлементов)
31. Column-gap - растояние между элементами, НЕ ДЕЛАЕМ ЭТО ЧЕРЕЗ margin
32. Ширину (расширение кнопки), лучше сделать через padding-inline, а не width
33. Cursos-pointer, добавляется только для ссылок (a), КНОПКИ НЕ ТРОГАЕМ!
34. Для того чтобы logo не сжималось flex-shrink: 0;
35. Чтобы текст у кнопок не переносился: white-space: nowrap; 
36. Дублировать элементы можно через box-shadow
37. Адаптированием занимаемся после каждого написанного крупного блока (БЭМ)
    - Через медиа запросы редактированием стили (order: 1 - изменение очередности элементов; flex-basis: 100% полная строчка только для этого элемента)
    - Минимальный размер экрана 360px, дальше не имеет смысла адаптировать
38. aspect-ratio: 1     Размер ширины и высоты 1 к 1, так можно указывать только ширину
41. Прячем элемент для screen-reader (Как прятать htmlacademy)

Section Banner:
1. Все секции всегда в теге main, class="content"
2. Каждый кусок сайта в main - section
3. h1 Заголовок только 1, вначале main. Заголовки идут последовательно, без пропуска уровней. Заголовки должны быть логичными и осмысленными
4. В каждой section, желательно иметь 1 заголовок h2
5. Исходя из 3. 4. => не всё что является по макету заголовком, будет являться им на уровне кода, а также не нужно полагаться на размер в макете
6. Следовательно мы должны заполнить сайт заголовками везде, а там где не нужны по макету - скрыть!
7. Время оборачиваем в тег time, а также атрибут datetime со значением времени в машино читаем виде (doka.guide/html/time)
8. Декоративные элементы (некоторые картинки), лучше задавать через css | background + такие элементы всегда лучше иметь как svg
9. Если ссылаемся на картинку или ещё что-то в css, то оборачиваем в url("")
10. Если не указывать кнопка атрибут type, то некоторые браузеры неявно присвоят атребут submit
11. Здесь мы начили писать стили для секции
12. text-transform: uppercase; !!!!
13. Ещё раз aspect-ration: 1; - Создание симметрии по кэфу
14. Если нужно задать и сверху и снизу padding, не нужно делать padding-inline и padding-block, проще задать это в padding: ...px ...px; (X, Y)
15. Для Section (больших объектов), никогда не задаём width и height, Правильно будет min-width и min-height;
16. Для того чтобы прижать контент к низу - display: flex; flex-direction: column; justify-content: end;
17. Если везде или у большиства цвет текста совпадает, задаём его в Section, а не у каждого элемента по отдельности
18. Если нужно выравнить весь блок, лучше использовать например end, а не flex-end, т. к. flex-end предназначен только для flex, а end будет работать и с grid, и c flex, и с block
19. Точно также column-gap, лучше использовать вместо grid-column-gap
20. Для картинок которые просто являются частью интерфейса, лучше не добавлять отдельный тег, а указывать через :before или :after, При этом не забываем добавлять content: '';
21. Правильно задаваь картинку так: background: url("./images/Arrow.svg") center/contain no-repeat; center- позиционирование, contain - Размер background-size (Заполнение всего пустого пространства contain), Не повторять изображение
22. Если нужно сделать 1 отступ используем margin, а не column-gap
23. На псевдоэлементы свойства размеров не действует, а если у родительского элемента flex, то начнёт действовать
24. У нас возникли проблемы с пробелами - Чтобы пофиксить указываем пробелы так - &nbsp;
25. У кнопок есть стандартные отступы их иногда нужно сбрасывать (padding: 0;)
26. Кнопки для слайдера мы увеличели по области нажатия, добавляя псевдоэлемент after
29. Для больших текстовых элементов задаём ширину в vw, формула: (размер / ширина макета) * 100 | 360 / 1920 * 100
30. Однако для больших экранов указывая vw, лучше ставить ограниченние по макету | для этого font-size: min(18.75vw, 360px) Браузер будет выбирать из них наименьшее
31. Если мы имеем дело с маленьким текстом, то его лучше всего указывать через clamp(min, rec, max) 
32. Отступы лучше менять в @media, им не нужно задавать vw
33. @media всегда в самом низу css и не должны дублироваться по ограничениям
34. Дизайнер подразумевает что будет использоваться 100% высоты секции на экране, для этого мы должны взять размер секции и отнять от него высоту шапки. calc(100vh - var(--header-height))
35. Проверяя сайт, замечаем что на маленьких размерах стрелка становится меньше маленького текста, фиксим также через clamp()

Section Motivation:
1. Повторяющиеся блоки могут быть в одном Section и сделаны как список ul и li, где li - 1 блок
2. Container только для ограничения ширины
3. Явные картинки - img, Неявные как та стрелка через стили. + такие фотки скачиваем как jpg
4. В images, делаем подпапку, не забываем структура проекта должна быть везде
5. Текст который будет скорее всего меняться (который написан рыбой), лучше всего оставлять без класса и обернутый в тег <p>
6. Такие элементы (5.) стилизуем через родительский класс
7. nth-child(even) - четные элементы
8. Картинки можно спокойно расширять margin`ом`
9. Для текста на фоне - relative
10. Чтобы элемент был поверх декаративных деталей - z-index: 2;
11. Ещё раз для элементов before, after, display хорошо бы указывать как block, чтобы применить размерность
12. В css, есть атрибут attr(), мы его применили для content: Чтобы получить значение из определенного атрибута
13. Для текста на фоне использовали единицы - em которые умножают родительские размеры на em, 
14. Можно использовать transparent для прозрачности текста, если у родителя текст не был задание
15. text-stroke - Обводка текста
16. Чтобы сделать элемент нижестоящим, z-index: -1
17. em Вообще указываем тогда, когда понимаем что позиционирование будет сильно зависить от шрифта (тогда выходит динамически)
18. Отступы задаём по системе слева-направа и сверху-вниз (margin-right, margin-bottom, остальное в исключительных случаях)
19. Медиа запросы должны быть сверху-вниз
20. Если нужно подстроить height под width, просто пишем auto

Section Training-types + Join Us:
1. Если изображение не несёт никакой смысловой нагрузки атрибут alt можно оставить пустым, однако полностью alt убирать нельзя!
2. Если мы хотим чтобы изображение из предыдущего блока не наезжала на этот, делаем position: relative и явно указываем background-color
3. Для списка мы применили display: grid; grid-template-columns: repeat(6, 1fr); где второе сетка из 6 блоков с равными фреймами
4. Ещё раз background: url(./icons/Arrow_diagonal-left-bottom.svg) 100% 0/ no-repeat; (100% и 0 это x и y - правый-верхний угол) после / это размер изображения
5. Видео указываем через тег video, у него также есть атрибут poster где можно поставить картинку
6. Также у видео как и у картинок указываем width и height
7. К input всегда добавляем label, а также делаем связь через for (label) и id (input)
8. Если label не видно, всё равно добавляем с классом visually-hidden
9. Для нестандартных инпутов всегда подбираем нужный type | type="email"
10. Если указываем background, то хорошим тоном будет указать запасной цвет, если картинка не появится (делается для больших блоков)
11. Если мы хотим чтобы какой-то элемент был absolute внутри другого элемента, то родитель должен быть relative
12. position: absolute; top: 50%; left: 50%; translate: -50% -50%; - такой набор свойтв гарантирует что элемент будет в центре
13. Разница между inline-flex и flex в том что flex - Вся ширина, inline-flex - указанная
14. Для перекраски белой стрелки можно использовать инверсию цвета - filter: invert(1)
15. Line-height у крупных текстов лучше всего ставить line-height: 1; также туда добавили text-align:center (без флексов)
16. Для поворота картинки: scale: 1 -1;
17. Чтобы задать цвет у placeholder, есть псевдоэлемент input::placeholder {}
18. .input:focus { outline: none; } - Сброс синего цвета у рамки при фокусе

Section Location:
1. Карту обычно делают через сторонние api, по типу google maps, но сейчас только картинка
2. Отступы (padding), следует иногда делать меньше чем в макете, чтобы не возникало проблем при адаптиве

Section Family:
1. Доп классы можно в будущем записывать в заметки с кратким пояснением чтобы не теряться
2. Обычно подобные картинки делаются slider`ом`, но пока только картинки
3. Если у нас множество картинок в слайдере, то можно дать для них одну объединяющую смысловую подпись
4. Чтобы придать элементу поведение слайдера - scroll-snap-type: x mandatory; + возможность скролить по горизнотали - overflow-x: scroll;
5. У самих же картинок указываем scroll-snap-align: start; - Скролл привязан к началу элемент слайда

Section Calculate:
1. У тега Select, всегда есть option, в нём важно указывать value с нижнего регистра, также можно сделать первое поле disabled и selected это будет образный placeholder
2. label есть у каждого поля формы!
3. У таблицы есть свои части thead - заголовки, tbody - содержимое, tfooter - подписи после таблицы. Класс для элементов таблицы не обязательны, так как обычно они настраиваются через table
4. tr - строка в таблице, th - ячейка / столбец
5. Повторить элемент можно через th*2 - напишет <th></th> <th></th>
6. td - ячейка которая растягивается на указанное в атрибуте colspan="2" столбца
7. Отдельные кусочки текста которые должны быть жирными, оборачиваем в тег <b>
8. flex-direction можно не указывать если мы подразумеваем row, т.к. он идёт там по умолчанию
9. flex-grow: 1; - указываем если хотим чтобы элемент стремился к своему приделу, хорошо работает в связке с max-width
10. Расширение элемента на всю ширину grid-column: -1 / 1;
11. Убираем стрелки у инпутов с type="number" - input[type="number"] {     -moz-appearance: textfield;   }   input::-webkit-outer-spin-button,   input::-webkit-inner-spin-button {     -webkit-appearance: none;   }
12. Покраска селектов происходит добавлением к input::placeholder селектору: select.input:invalid {    color: var(--color-light-grey);  }
13. 12 Возможно только если у select указать атрибут required
14. Сам выпадающий список не выйдет стилизовать, или же потребуется использовать кастомную библиотеку, или же самому написать свой селектов
15. Ещё раз если центруем абсолютный элемент не забываем добавлять translate: -50% -50%;
16. border-collapse: collapse; - Убираем невидимые границы у ячеек таблицы
17. Можно обратиться к сразу нескольким элементам с помощью псевдокласса :is() - .calculate__table :is(td, th)

Footer:
1. Текст описания где упоминалась почта, обернули тегом <a> с атрибутом href="mailto:kropp@qodeinteractive.com"
2. В списке всегда нужно оборачивать однотипную информацию, поэтому footer через дивы
3. Так как информация в <p> всегда будет одна и та же, можно не оборачивать в div
4. Не забываем время обернуть в <time> и добавить атрибут datetime="00:00/24:00", запись всегда разная
5. Есть семантический тег - address
6. Для того чтобы сделать ссылку на телефон - <a href="tel:+17184076400" class="footer__contacts-link">+ (1) 718 - 407 - 6400</a
7. Пояснение к 6., мы должны убрать все символы кроме + в телефоне и указать tel: вначале
8. Если есть кнопка, но у неё нет соправодительного текста, добавляем невидимый span, а также атрибут title="", с тем же самым названием
9. Необычный факт, при указании класса socials, заменяем i на 1 = soc1als, для того чтобы adblock, не блокировал эти элементы
10. Для ссылок соцсетей добавляем атрибут target="_blank" - Для их открытия в новом окне
11. 10 - Нужно делать для всех ссылок ведущих на сторонние ресурсы
12. Font Awesome 5 Brands - плохой шрифт с помощью которого сделаны картинки, лучше взять на стороннем ресурсе, если будут такие же как по макету
13. 12 Плохой, потому что не хороший по производительности
14. Я добавил расширение позволяющее узнать код svg, без ненужной информации, остается только убрать width и height
15. Обычно вручную svg не очищают
16. Через grid делаем сетку между header и body, Для этого вычисляем в процентном соотношении лого, Указываем в стилях: .footer__header {display: grid; grid-template-columns: 20.77% auto;}
17. А в body делаем - .footer__body {display: grid; grid-template-columns: 20.77% repeat(3, 1fr); }
18. Таким образом у нас 16 и 17 начнутся вместе со второй колонки
19. address делает шрифт Italic, поэтому иногда его нужно сбрасывать на normal
20. Покраска svg - В css пишем svg *[fill] { fill: CurrentColor} svg *[stroke] { stroke: CurrentColor}, если что-то непокрасилось можно svg path {fill: }
21. Если transition-duration багованный, прописываем svg * {transition-duration: fill, stroke}, явно указывая для каких свойств происходит анимация